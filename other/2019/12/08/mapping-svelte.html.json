{"title":"Mapping with Svelte and D3js","contents":"<p><a href=\"https://svelte.dev/\">Svelte</a> is a very nice framework for building user interfaces. I wanted to learn more about it, and loved that the <em>d3-like</em> transitions are included and well documented, and much easier than in React, that is my daily library.</p>\n<p>So I thought that some cool mapping examples could be done easily and I was right, so here we go!</p>\n<p>Don&#39;t want to read all this? Check the examples:</p>\n<ul>\n<li><a href=\"https://bl.ocks.org/rveciana/4071d3c6a0b58f98893fb311306b038c\">Example 1: Basic map</a></li>\n<li><a href=\"https://bl.ocks.org/rveciana/9026255839233498dbe979ea69ad3af2\">Example 2: Multiple geometries and color scale</a></li>\n<li><a href=\"https://bl.ocks.org/rveciana/a8f24ce0ea98e403e266dfb4f9b6b2e9\">Example 3: Adding transitions</a></li>\n<li><a href=\"https://bl.ocks.org/rveciana/653784cfab5d859610926733cfb14773\">Example 4: Adding circles</a></li>\n</ul>\n<h2 id=\"dom-projections-and-scales\">DOM, projections and scales</h2>\n<p>Svelte controls the DOM (<a href=\"https://svelte.dev/blog/virtual-dom-is-pure-overhead\">not with a virtual DOM as React or Vue</a>), and has no projection functions for mapping. I wanted to keep all the control into Svelte, so no D3js has been used for this, unlike many of the React with D3 examples out there. Svelte&#39;s <a href=\"https://svelte.dev/tutorial/tweened\">Tweened</a> can do this perfectly.</p>\n<p>On the other hand, D3 has been splitted long ago into several parts, in a really nice decision. This allows us to take only the parts we want and use them anywhere. The examples will use the projections and scales provided by D3 to calculate the paths.</p>\n<h2 id=\"installing-the-examples\">Installing the examples</h2>\n<p>The easiest way to start any Svelte project is running:</p>\n<pre><code>npx degit sveltejs/template svelte-app\ncd svelte-app\nnpm run dev</code></pre><p>This will download the tempate project and run it at the port 5000. All the changes to be done are in the <em>App.svelte</em> file.</p>\n<p>So, for all these examples, create a project and start manipulating the <em>App.svelte</em> file with the provided code.</p>\n<p>To run all the examples, severall libraries have to be installed too:</p>\n<pre><code>npm install topojson, d3-geo, d3-composite-projections, d3-scale, d3-color, d3-interpolate</code></pre><h2 id=\"basic-map\">Basic map</h2>\n<p><a href=\"https://bl.ocks.org/rveciana/4071d3c6a0b58f98893fb311306b038c\">This first example</a> creates the easiest map:</p>\n<img width=\"50%\" src=\"/images/d3/mapping-svelte/example1.png\"/>\n\n<p>The <em>App.svelte</em> file would be:</p>\n<p>\n<script>\n  import { geoAlbers, geoPath } from \"d3-geo\";\n  import { onMount } from \"svelte\";\n  import { feature } from \"topojson\";\n  let data;\n  const projection = geoAlbers();\n  const path = geoPath().projection(projection);\n\nonMount(async function() {\nconst response = await fetch(\n\"https://gist.githubusercontent.com/rveciana/a2a1c21ca1c71cd3ec116cc911e5fce9/raw/79564dfa2c56745ebd62f5655a6cc19d2cffa1ea/us.json\"\n);\nconst json = await response.json();\nconst land = feature(json, json.objects.land);\ndata = path(land);\n});\n</script>\n\n<style>\n  svg {\n    width: 960px;\n    height: 500px;\n  }\n  .border {\n    stroke: #444444;\n    fill: #cccccc;\n  }\n</style>\n\n<svg width=\"960\" height=\"500\">\n  <path d={data} class=\"border\" />\n</svg>\n\n\n<ul>\n<li>The file is structured in three parts:<ul>\n<li>script, where all the JavaScript goes</li>\n<li>style, where the css for the map is set</li>\n<li>The template part, where the HTML elements are defined</li>\n</ul>\n</li>\n<li>The <em>onMount</em> function is run only once, when the component is mounted. Is here where we will fetch the JSON data we need to draw the map.<ul>\n<li><em>feature</em> is the function from the <a href=\"https://github.com/topojson/topojson-client/blob/master/README.md#feature\">topojson library to decode the topojson file</a></li>\n<li><em>data</em> will have the svg path definition fot the map. Why is declared outside the <em>onMount</em> function? Because it&#39;s used in the template, and since <em>onMount</em> is <em>async</em>, the variable wouldn&#39;t be available when the component is created, giving an error. By doing it this way, the path will be null at the beginning, and the component will re-render when the data is loaded.</li>\n</ul>\n</li>\n<li>Note that path and projection are taken directly from D3js, but are only pure functions that return the SVG path string given a GeoJSON data. Nothing related to the DOM</li>\n<li>The path is defined to hold the <em>data</em> value as the d attribute</li>\n</ul>\n<h2 id=\"adding-multiple-geometries-and-color-scale\">Adding multiple geometries and color scale</h2>\n<p>Let&#39;s add now more geometries and a color scale to fill them. This example and the next ones are all based on <a href=\"https://observablehq.com/@rveciana/use-composite-projections-scotland\">this Observable</a>. <a href=\"https://bl.ocks.org/rveciana/9026255839233498dbe979ea69ad3af2\">Check the result</a></p>\n<img width=\"50%\" src=\"/images/d3/mapping-svelte/example2.png\"/>\n\n<p>\n<script>\n  import { geoAlbers, geoPath } from \"d3-geo\";\n  import { scaleLinear } from \"d3-scale\";\n  import { extent } from \"d3-array\";\n  import { onMount } from \"svelte\";\n  import { feature } from \"topojson\";\n  let data = [];\n  let colorScale = () => {};\n  const width = \"960\";\n  const height = \"500\";\n  const projectionAlbers = geoAlbers()\n    .rotate([4.4, 0.8])\n    .center([0, 55.4])\n    .parallels([50, 60])\n    .scale(3800)\n    .translate([width / 2, (1.8 * height) / 2]);\n\n  let currentProj = projectionAlbers;\n  let path = geoPath().projection(currentProj);\n\n  onMount(async function() {\n    const response = await fetch(\n      \"https://gist.githubusercontent.com/rveciana/27272a581e975835aaa321ddf816d726/raw/c40062a328843322208b8e98c2104dc8f6ad5301/uk-counties.json\"\n    );\n    const json = await response.json();\n    const topoData = feature(json, json.objects.UK);\n    const land = {\n      ...topoData,\n      features: topoData.features.filter(\n        d => d.properties.NAME_1 === \"Scotland\"\n      )\n    };\n\n    const namesExtent = extent(land.features, d => d.properties.NAME_2.length);\n    colorScale = scaleLinear()\n      .domain(namesExtent)\n      .range([\"#feedde\", \"#fd8d3c\"]);\n    data = land.features;\n  });\n</script>\n\n<style>\n  svg {\n    width: 960px;\n    height: 500px;\n    background-color: \"#eeeeee\";\n  }\n  .provinceShape {\n    stroke: #444444;\n    stroke-width: 0.5;\n  }\n</style>\n\n<svg width=\"960\" height=\"500\">\n  {#each data as feature}\n    <path\n      d={path(feature)}\n      class=\"provinceShape\"\n      fill={colorScale(feature.properties.NAME_2.length)} />\n  {/each}\n</svg>\n\n\n<ul>\n<li>We are using now another projection (<a href=\"https://github.com/d3/d3-geo#geoAlbers\">geoAlbers</a>), so the next examples become more interesting</li>\n<li>All the strange stuff with the topojson data is to get only the Scotland counties from the file that contains all the UK counties</li>\n<li>Note the use of <em>scaleLinear</em> to get a color scale. The extent is only the minimum and maximum length of the names of the counties. Just to have some data to plot!</li>\n<li>Now, in the template part, an <em>each</em> block is used to plot a different path for each county. The color is calculated with the color scale</li>\n<li>Note that, again, the color scale and data have to be declared outside the <em>onMount</em> block</li>\n</ul>\n<h2 id=\"changing-the-color-when-mouse-is-over\">Changing the color when mouse is over</h2>\n<p>Well, this starts to be interesting. This is where Svelte makes things really easier. We want the same map we had on the previous example but when we hover on a county, we want this county color change a little so the user knows it. This means having behaviours for each path, so we will need nested components.\nAlso, we want to change the projection to a composed one when clicking a button. <a href=\"https://bl.ocks.org/rveciana/a8f24ce0ea98e403e266dfb4f9b6b2e9\">Check the result</a></p>\n<img width=\"50%\" src=\"/images/d3/mapping-svelte/example3.png\"/>\n\n<p>Let&#39;s start with the nested component, called <em>Feature.svelte</em>. Copy this into your project too!</p>\n<p>\n<script>\n  import { tweened } from \"svelte/motion\";\n  import { interpolateLab } from \"d3-interpolate\";\n  import { rgb } from \"d3-color\";\n  export let featurePath;\n  export let initialColor;\n\n  const color = tweened(initialColor, {\n    duration: 300,\n    interpolate: interpolateLab\n  });\n</script>\n\n<style>\n  .provinceShape {\n    stroke: #444444;\n    stroke-width: 0.5;\n  }\n</style>\n\n\n<path\nd={featurePath}\nclass=\"provinceShape\"\nfill={$color}\non:mouseover={() => {\ncolor.set(rgb(initialColor).brighter(0.3));\n}}\non:mouseout={() => {\ncolor.set(initialColor);\n}} />\n</p>\n<ul>\n<li>The idea, as you can see on the tempalte section, is rendering only the SVG path element. The path itself is given by a prop (note the export on the 4th line)</li>\n<li>The <em>color</em> variable is now a <a href=\"https://svelte.dev/tutorial/tweened\">tweened function</a>.<ul>\n<li>The first parameter is the initial color, given by a prop calculated the same way as in the previous example, in the parent component</li>\n<li>The interpolation function for a color is not given by Svelte, but a D3 function can be perfectly used. It&#39;s actually what the <a href=\"https://svelte.dev/tutorial/tweened\">Svelte docs recommend to do</a></li>\n<li>The events <em>onmouseover</em> and <em>onmouseout</em> are ones that change this value. Instead of being changed directly, they are changed many times, interpolating the values. These values are read as in a store, so a $ sign has to be used to access the <em>color</em> variable value.</li>\n<li>The <em>rgb.brighter</em> function is used to calculate a new color for each region</li>\n</ul>\n</li>\n</ul>\n<p>Let&#39;s see now the <em>App.svelte</em> file. This will handle the projection transition and the <em>Feature</em> rendering:</p>\n<p>\n<script>\n  import { geoAlbers, geoPath, geoProjection } from \"d3-geo\";\n  import { geoAlbersUk } from \"d3-composite-projections\";\n  import { scaleLinear } from \"d3-scale\";\n  import { extent } from \"d3-array\";\n  import { onMount } from \"svelte\";\n  import { feature } from \"topojson\";\n  import { tweened } from \"svelte/motion\";\n  import { interpolate } from \"d3-interpolate\";\n  import Feature from \"./Feature.svelte\";\n\n  let data = [];\n  let colorScale = () => {};\n  const width = \"960\";\n  const height = \"500\";\n  const projectionAlbers = geoAlbers()\n    .rotate([4.4, 0.8])\n    .center([0, 55.4])\n    .parallels([50, 60])\n    .scale(3800)\n    .translate([width / 2, (1.8 * height) / 2]);\n\n  const projectionAlbersUk = geoAlbersUk()\n    .translate([width / 2, (1.85 * height) / 2])\n    .scale(5200);\n\n  const projectionTween = (projection0, projection1) => {\n    return function(t) {\n      function project(λ, φ) {\n        (λ *= 180 / Math.PI), (φ *= 180 / Math.PI);\n        var p0 = projection0([λ, φ]),\n          p1 = projection1([λ, φ]);\n        if (!p0 || !p1) return [0, 0];\n        return [(1 - t) * p0[0] + t * p1[0], (1 - t) * -p0[1] + t * -p1[1]];\n      }\n\n      return geoProjection(project)\n        .scale(1)\n        .translate([0, 0]);\n    };\n  };\n\n  const currentProj = tweened(projectionAlbers, {\n    duration: 1000,\n    interpolate: projectionTween\n  });\n\n  $: path = geoPath().projection($currentProj);\n\n  const opacity = tweened(0, {\n    duration: 1000\n  });\n\n  onMount(async function() {\n    const response = await fetch(\n      \"https://gist.githubusercontent.com/rveciana/27272a581e975835aaa321ddf816d726/raw/c40062a328843322208b8e98c2104dc8f6ad5301/uk-counties.json\"\n    );\n    const json = await response.json();\n    const topoData = feature(json, json.objects.UK);\n    const land = {\n      ...topoData,\n      features: topoData.features.filter(\n        d => d.properties.NAME_1 === \"Scotland\"\n      )\n    };\n\n    const namesExtent = extent(land.features, d => d.properties.NAME_2.length);\n    colorScale = scaleLinear()\n      .domain(namesExtent)\n      .range([\"#feedde\", \"#fd8d3c\"]);\n    data = land.features;\n  });\n</script>\n\n<style>\n  svg {\n    width: 960px;\n    height: 500px;\n    background-color: \"#eeeeee\";\n  }\n  .borders {\n    fill: #ddd;\n  }\n</style>\n\n\n<button\non:click={() => {\ncurrentProj.set($currentProj === projectionAlbers ? projectionAlbersUk : projectionAlbers);\n    opacity.set($currentProj === projectionAlbers ? 1 : 0);\n}}>\nChange\n</button>\n<svg width=\"960\" height=\"500\">\n<path\n    class=\"borders\"\n    d={projectionAlbersUk.getCompositionBorders()}\n    style=\"opacity: {$opacity}\" />\n{#each data as feature}\n<Feature\n      featurePath={path(feature)}\n      initialColor={colorScale(feature.properties.NAME_2.length)} />\n{/each}\n</svg>\n\n\n</p>\n<ul>\n<li><a href=\"https://github.com/rveciana/d3-composite-projections\">projectionAlbersUk</a> is a composite projection that makes the Shetland islands closer to the mainland. <a href=\"http://www.legislation.gov.uk/asp/2018/12/contents\">Be careful, this can&#39;t be illegal! ;)</a></li>\n<li><em>projectionTween</em> makes the magic. It takes two projections and creates the interpolated projection. The return value is a function of t. t can be a value from 0 to 1. This way, the interpolation can run from 0 to 1, and the path will be recalculated with these intermediate projections. See how is used in the <em>currentProj</em> variable. It&#39;s a cool demonstration that <em>tweened</em> can interpolate anything if you give the proper function to do it</li>\n<li><em>opacity</em> is another tweened store used to add and remove the rectangle indicator. There is a fade option in Svelte that makes it even easier</li>\n<li>Note that now, instead of adding an SVG path, many <em>Feature</em> components are added so they can handle their behaviour independently. Doing it altogether in the main component is terribly complicated and ugly</li>\n</ul>\n<h2 id=\"adding-circles\">Adding circles</h2>\n<p>The last example is just to show that the usual extra data can be added without any problem.</p>\n<img width=\"50%\" src=\"/images/d3/mapping-svelte/example4.png\"/>\n\n<p>I won&#39;t put all the code, since it&#39;s very similar to the previous one. <a href=\"https://bl.ocks.org/rveciana/653784cfab5d859610926733cfb14773\">Check the example here</a></p>\n<ul>\n<li>cities.js has an array with the locations and the populations. The sizes of the circles are calculated using the d3 <em>scaleSqrt</em> scale, so the area is proportional to the population, not the radius.</li>\n<li>An each block is used to draw each circle as in the second example. Since they have no individual behaviour, no extra components are needed</li>\n</ul>\n<p>cities.js:</p>\n<p>\nexport const cities = [\n{ name: \"Perth\", lat: 56.396999, lon: -3.437, population: 47180 },\n{ name: \"Glasgow\", lat: 55.860916, lon: -4.251433, population: 598830 },\n{ name: \"Dundee\", lat: 56.462002, lon: -2.9707, population: 148270 },\n{ name: \"Dundee\", lat: 56.462002, lon: -2.9707, population: 148270 },\n{ name: \"Elgin\", lat: 57.653484, lon: -3.335724, population: 23128 },\n{ name: \"Edinburgh\", lat: 55.953251, lon: -3.188267, population: 482005 },\n{ name: \"Edinburgh\", lat: 55.953251, lon: -3.188267, population: 482005 },\n{ name: \"Inverness\", lat: 57.477772, lon: -4.224721, population: 46870 },\n{ name: \"Lerwick\", lat: 60.154167, lon: -1.148611, population: 6958 }\n];\n</p>\n<h2 id=\"final-thoughts\">Final thoughts</h2>\n<p>Although I have experience with React, I am really new to Svelte. Besides loving how is done, what impressed me the most is how easy is to make all the <em>traditional</em> D3js visualizations, but with the power of having an organized framework with components, stores, that is really fast and produces small bundles, etc.</p>\n<p>I&#39;m sure I&#39;ve made many errors and that the code can be better, but I would spend a lot of hours replicating data visualizations into Svelte if I had time. Give it a try!</p>\n<h2 id=\"links\">Links</h2>\n<ul>\n<li><a href=\"https://bl.ocks.org/rveciana/4071d3c6a0b58f98893fb311306b038c\">Example 1: Basic map</a></li>\n<li><a href=\"https://bl.ocks.org/rveciana/9026255839233498dbe979ea69ad3af2\">Example 2: Multiple geometries and color scale</a></li>\n<li><a href=\"https://bl.ocks.org/rveciana/a8f24ce0ea98e403e266dfb4f9b6b2e9\">Example 3: Adding transitions</a></li>\n<li><a href=\"https://bl.ocks.org/rveciana/653784cfab5d859610926733cfb14773\">Example 4: Adding circles</a></li>\n<li><a href=\"https://svelte.dev/\">Svelte web site</a></li>\n<li><a href=\"https://svelte.dev/blog/virtual-dom-is-pure-overhead\">Virtual DOM is pure overhead</a></li>\n<li><a href=\"https://svelte.dev/tutorial/tweened\">Svelte&#39;s Tweened function</a></li>\n<li><a href=\"https://github.com/topojson/topojson-client/blob/master/README.md#feature\">Topojson feature function</a></li>\n<li><a href=\"https://observablehq.com/@rveciana/use-composite-projections-scotland\">Scotland map Observable example</a></li>\n<li><a href=\"https://github.com/d3/d3-geo#geoAlbers\">The geoAlbers projection</a></li>\n<li><a href=\"https://github.com/rveciana/d3-composite-projections\">d3-composite-projections</a></li>\n<li><a href=\"http://www.legislation.gov.uk/asp/2018/12/contents\">Islands (Scotland) Act 2018</a></li>\n</ul>\n","tags":["svelte","projections","svg"],"date":"2019-12-08T00:00:00.000Z"}