<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="manifest" href="/manifest.json" />
		<meta name="theme-color" content="#cdffcd">
		<!-- HTML Meta Tags -->
		<title>GeoExamples - Roger Veciana</title>
		<meta
			name="description"
			content="I am a software developer and meteorologist who likes mapping. I put here the things I learn on my free time."
		/>
		<!-- Google / Search Engine Tags -->
		<meta itemprop="name" content=">GeoExamples - Roger Veciana" />
		<meta
			itemprop="description"
			content="I am a software developer and meteorologist who likes mapping. I put here the things I learn on my free time."
		/>
		<meta itemprop="image" content="https://geoexamples.com/siteImage.png" />
		<!-- Facebook Meta Tags -->
		<meta property="og:url" content="https://geoexamples.com" />
		<meta property="og:type" content="website" />
		<meta property="og:title" content="GeoExamples - Roger Veciana" />
		<meta
			property="og:description"
			content="I am a software developer and meteorologist who likes mapping. I put here the things I learn on my free time."
		/>
		<meta property="og:image" content="https://geoexamples.com/siteImage.png" />
		<!-- Twitter Meta Tags -->
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:title" content="GeoExamples - Roger Veciana" />
		<meta name="twitter:description"
		  content="I am a software developer and meteorologist who likes mapping. I put here the things I learn on my free time." />
		<meta name="twitter:image" content="https://geoexamples.com/siteImage.png" />
		



<link rel="modulepreload" href="/./_app/start-44631b0b.js">
			<link rel="modulepreload" href="/./_app/chunks/vendor-ff3d1764.js">
			<link rel="modulepreload" href="/./_app/chunks/config-b3bde751.js">
			<link rel="modulepreload" href="/./_app/pages\[category]\[year]\[month]\[date]\[slug].svelte-a77716b3.js">
			<link rel="stylesheet" href="/./_app/assets/start-34a290f9.css">


		<script type="module">
			import { start } from "/./_app/start-44631b0b.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":"/."},
				session: {},
				host: location.host,
				route: true,
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/./_app/pages\\[category]\\[year]\\[month]\\[date]\\[slug].svelte-a77716b3.js")
					],
					page: {
						host: location.host, // TODO this is redundant
						path: "/other/2018/09/18/gpujs-mapping-performance.html",
						query: new URLSearchParams(""),
						params: {"category":"other","year":"2018","month":"09","date":"18","slug":"gpujs-mapping-performance.html"}
					}
				}
			});
		</script>
	</head>
	<body>
		<div id="svelte">


<header class="site-header"><div class="wrapper"><a class="site-title" href="/">GeoExamples - Roger Veciana</a>

<nav class="site-nav"><div href="#" class="menu-icon"><svg viewBox="0 0 18 15"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></div>

	<div class="trigger"><a class="page-link" href="/about">About</a><a class="page-link" href="/blog">Blog</a><a class="page-link" href="/projects">Projects</a></div></nav></div></header>

<main class="page-content"><div class="wrapper"><div class="post"><header class="post-header"><h1 class="post-title">gpu.js performance</h1>
<p class="post-meta">Sep 18, 2018</p></header>

	<article class="post-content"><p>In the [last post][1] we explained how to make a little more complex calculations with [gpu.js][2]. But, how efficient is?</p>
<p>The temperature calculation is a task I did many years ago, with pure python. Using pure python is a really bad idea in this case, having tools like numpy, cython, etc. The times were about 50 seconds or more, while gpu.js lasts about 1.5 seconds! More than an order of magnitude.</p>
<h2 id="the-code">The code</h2>
<p>I made an [example script][3] to test the timing. The result should be the same [as in gpu.js][1], but I made the residuals interpolation calculations in different alternatives, two of them may be different.</p>
<p>To run the script you will need two things:</p>
<h3 id="dependencies">Dependencies</h3>
<p>My <em>pip list</em> command returns this:</p>
<pre><code>cycler (0.10.0)
Cython (0.28.5)
GDAL (2.3.1)
matplotlib (2.2.3)
numpy (1.15.1)
scikit-learn (0.19.2)
scipy (1.1.0)
sklearn (0.0)</code></pre><p>Basically, scikit-learn, with numpy and scipy plus the cython library. Also, matplotlib to plot the data.</p>
<p>To compile the cython part, there is a <em>setup.py</em> file that has to be run by:</p>
<pre><code>python setup.py build_ext --inplace</code></pre><p>Now, by running</p>
<pre><code>python calculate_temp.py</code></pre><p>You will get all the benchmarks</p>
<h3 id="multi-linear-regression">Multi linear regression</h3>
<p>To get the regression coefficients, I used scikit-learn:

def calculate_regression(data_file):
regr = LinearRegression()
<pre><code>with open(data_file) as f_p:
    data = load(f_p)
    temps = []
    predictors = []
    lats = []
    lons = []
    for station_data in data:
        temps.append(station_data[&#39;temp&#39;])
        predictors.append([station_data[&#39;alt&#39;], station_data[&#39;dist&#39;]])
        lats.append(station_data[&#39;lat&#39;])
        lons.append(station_data[&#39;lon&#39;])

    regr.fit(predictors, temps)
    score = regr.score(predictors, temps)
    residuals = regr.predict(predictors) - temps

    print("Multiple linear regression score: {}".format(score))
    return {&#39;coefs&#39;: regr.coef_, &#39;intercept&#39;: regr.intercept_,
            &#39;residuals&#39;: array(residuals),
            &#39;lats&#39;: array(lats), &#39;lons&#39;: array(lons)}</code></pre>
</p>
<p>Which is quite straightforward. Just prepare the data and [follow the docs][6].</p>
<p>Note that the residuals are created applying the regression to the original data:</p>
<pre><code>residuals = regr.predict(predictors) - temps</code></pre><p>It&#39;s a clean and fast way to do it and allows to access the results later in the script.</p>
<h3 id="applying-the-regression">Applying the regression</h3>
<p>Applying the regression results is easy with numpy, since it&#39;s just adding several matrices:

def create*regression_field(regression, vars_file):
d_s = gdal.Open(vars_file)
distances = d_s.GetRasterBand(1).ReadAsArray()
altitudes = d_s.GetRasterBand(2).ReadAsArray()
temperature = (regression[&#39;intercept&#39;] +
altitudes * regression[&#39;coefs&#39;][0] +
distances _ regression[&#39;coefs&#39;][1])
return temperature
</p>
<h3 id="interpolating-the-residuals">Interpolating the residuals</h3>
<p>Interpolating the residuals can be done in several ways. I&#39;ve tested three, two after looking example around and the original I used both at my workplace and in the gpu.js example.</p>
<h4 id="rbf">rbf</h4>
<p>The [radial basis function][8] is the one most srecommended by scipy. The results can be a bit strange and the performance is poor, but:</p>
<p>
def rbf(regression, dimensions):
xi = linspace(regression[&#39;lons&#39;].min(), regression[&#39;lons&#39;].max(),
dimensions[1])
yi = linspace(regression[&#39;lats&#39;].min(), regression[&#39;lats&#39;].max(),
dimensions[0])
xi, yi = meshgrid(xi, yi)
xi, yi = xi.flatten(), yi.flatten()
interp = Rbf(regression[&#39;lons&#39;], regression[&#39;lats&#39;],
regression[&#39;residuals&#39;], function=&#39;linear&#39;)
<pre><code>residuals_field = interp(xi, yi).reshape(dimensions)
return residuals_field</code></pre>
</p>
<p>The code, basically prepares the data for the <em>Rbf</em> function.</p>
<h3 id="idw">idw</h3>
<p>The inverse of the distance weighted code is [taken from a GitHub repo][9]. It&#39;s really efficient and the result is good, but more difficult to understand than the regular inverse of the distance. Also, maintains steep changes, which is not the best situation in our case, where we want a smooth residuals field all around, even if a single station has a different local value:</p>
<p>
def idw(regression, dimensions):
X1 = array(list(zip(regression[&#39;lons&#39;], regression[&#39;lats&#39;])))
<pre><code>idw_tree = tree(X1, regression[&#39;residuals&#39;])

xi = linspace(regression[&#39;lons&#39;].min(), regression[&#39;lons&#39;].max(),
              dimensions[1])
yi = linspace(regression[&#39;lats&#39;].min(), regression[&#39;lats&#39;].max(),
              dimensions[0])
X2 = meshgrid(xi, yi)
X2 = reshape(X2, (2, -1)).T
z2 = idw_tree(X2)

return z2.reshape(dimensions)</code></pre>
</p>
<p>Again, the code is basically preparing the data for the function.</p>
<h3 id="inverse-of-the-distance-using-cython">Inverse of the distance using cython</h3>
<p>This is the original code I used, and the one in the [previous post][1]. Calculating it with pure numpy was a bit difficult, so I made the original algorithm optimized with [cython][10], so it&#39;s as fast as coded in C. The code to call it is:</p>
<p>
def cython_id(regression, dimensions):
<pre><code>data = {}

for i in range(len(regression[&#39;lons&#39;])):
    data[i] = {&#39;x&#39;: regression[&#39;lons&#39;][i],
               &#39;y&#39;: regression[&#39;lats&#39;][i],
               &#39;value&#39;: regression[&#39;residuals&#39;][i]}

geotransform = [min(regression[&#39;lons&#39;]),
    (max(regression[&#39;lons&#39;]) - min(regression[&#39;lons&#39;]))/dimensions[1],
    0,
    max(regression[&#39;lats&#39;]),
    0,
    (min(regression[&#39;lats&#39;]) - max(regression[&#39;lats&#39;]))/dimensions[0]
]

result = interpolate_residuals(data, dimensions, geotransform)
return result</code></pre>

Note that I used geotransform, which turns things properly.</p>
<p>The cython code is:

#cython: boundscheck=False, wraparound=False, nonecheck=False, cdivision=True

import numpy as np
cimport numpy as np
from libc.math cimport sqrt
from libc.math cimport pow
from cpython cimport array
import array

DTYPE = np.float64
ctypedef np.float64_t DTYPE_t

def interpolate_residuals(residues, size, geotransform):
cdef array.array da = array.array(&#39;d&#39;, [])
array.resize(da, size[0] * size[1])
cdef double[:] cda = da
<pre><code>xpos0 = []
ypos0 = []
values0 = []

for key in residues.keys():
    xpos0.append(residues[key][&#39;x&#39;])
    ypos0.append(residues[key][&#39;y&#39;])
    values0.append(residues[key][&#39;value&#39;])

cdef int N
N = len(xpos0)
#http://cython.readthedocs.io/en/latest/src/tutorial/array.html
cdef array.array xpos = array.array(&#39;d&#39;, xpos0)
cdef double[:] cxpos = xpos
cdef array.array ypos = array.array(&#39;d&#39;, ypos0)
cdef double[:] cypos = ypos
cdef array.array values = array.array(&#39;d&#39;, values0)
cdef double[:] cvalues = values

cdef int i, j
cdef int xsize = size[1]
cdef int ysize = size[0]
cdef double y
cdef double x

cdef array.array geotransform0 = array.array(&#39;d&#39;, geotransform)
cdef double[:] cgeotransform = geotransform0

for j in range(ysize):
    y = cgeotransform[3] + j * cgeotransform[5]
    for i in range(xsize):
        x = cgeotransform[0] + i * cgeotransform[1]
        cda[i + j * xsize] = point_residue(x, y, cxpos, cypos, cvalues, N)

data_array = np.array(cda)
return data_array.reshape(size)</code></pre>
cdef float point_residue(double x, double y, double[:] xpos, double[:] ypos, double[:] values, int N):
cdef int power = 2
cdef int smoothing = 0
cdef double numerator = 0
cdef int i
cdef double denominator
denominator = 0
<pre><code>for i in range(N):
    dist = sqrt((x - xpos[i]) ** 2 + (
        y - ypos[i]) ** 2 + smoothing * smoothing)

    if dist < 0.00000000001:
        return values[i]
    numerator = numerator + (values[i] / pow(dist, power))
    denominator = denominator + (1 / pow(dist, power))

if denominator != 0:
    return numerator / denominator</code></pre>
</p>
<p>You have to run</p>
<pre><code>python setup.py build_ext --inplace</code></pre><p>to compile it before running the script for the first time.</p>
<h2 id="results">Results</h2>
<p>In my computer, which is not a new or powerful one, the times were, for the common steps:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Elapsed time</th>
</tr>
</thead>
<tbody><tr>
<td>Regression time</td>
<td>3 ms</td>
</tr>
<tr>
<td>Temperature field time</td>
<td>44 ms</td>
</tr>
<tr>
<td>Final field time</td>
<td>2 ms</td>
</tr>
<tr>
<td>Drawing time</td>
<td>402 ms</td>
</tr>
</tbody></table>
<p>With the different methods, the times were:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Residuals field time</th>
<th>Total time</th>
</tr>
</thead>
<tbody><tr>
<td>Rbf</td>
<td>4101 ms</td>
<td>4551 ms</td>
</tr>
<tr>
<td>idw</td>
<td>881 ms</td>
<td>1084 ms</td>
</tr>
<tr>
<td>cython</td>
<td>2571 ms</td>
<td>2775 ms</td>
</tr>
</tbody></table>
<p>So, in the first place, the residuals interpolation is, by far, the most expensive step. The IDW method I found is the fastest option, although I&#39;m not sure that the result is as good as the cython method with the classical inverse of the distance.</p>
<p>The original gpu.js method lasted:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Elapsed time</th>
</tr>
</thead>
<tbody><tr>
<td>Multiple linear regression</td>
<td>2 ms</td>
</tr>
<tr>
<td>Calculate the regression field</td>
<td>209 ms</td>
</tr>
<tr>
<td>Calculate the residuals field</td>
<td>1084 ms</td>
</tr>
<tr>
<td>Calculate the final field</td>
<td>52 ms</td>
</tr>
<tr>
<td>Draw the regression field</td>
<td>65 ms</td>
</tr>
<tr>
<td>Draw residuals field</td>
<td>70 ms</td>
</tr>
<tr>
<td>Draw final result</td>
<td>67 ms</td>
</tr>
<tr>
<td><strong>Total time</strong></td>
<td><strong>1549 ms</strong></td>
</tr>
</tbody></table>
<p>So it&#39;s a really good performance if you think that it&#39;s run on the browser using a non compiled language (although using the GPU, of course!)</p>
<p>Finally, it would be nice to check the performance against python + GPU, but I have never worked with it.</p>
<h2 id="links">Links</h2>
<ul>
<li><p>[Last post: Complex GIS calculations with gpu.js: Temperature interpolation][1]</p>
</li>
<li><p>[The gpu.js web site][2]</p>
</li>
<li><p>[scikit-learn multiple linear regression][7]</p>
</li>
<li><p>[The example script][3]</p>
</li>
<li><p>[setup.py for cython][4]</p>
</li>
<li><p>[The cython function][5]</p>
</li>
<li><p>[idw file][6]</p>
</li>
<li><p>[The vars.tiff file][11]</p>
</li>
<li><p>[The station data file][12]</p>
</li>
<li><p>[radial basis function][8]</p>
</li>
<li><p>[IDW library][9]</p>
</li>
<li><p>[cython][10]</p>
</li>
</ul>
<p>[1]: /other/2018/09/17/gpujs-example.html
[2]: <a href="http://gpu.rocks">http://gpu.rocks</a>
[3]: /images/python/gpujs-performance/calculate_temp.py
[4]: /images/python/gpujs-performance/setup.py
[5]: /images/python/gpujs-performance/interpolate_residuals.pyx
[6]: /images/python/gpujs-performance/idw.py
[7]: scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html
[8]: <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html</a>
[9]: <a href="https://github.com/paulbrodersen/inverse_distance_weighting">https://github.com/paulbrodersen/inverse_distance_weighting</a>
[10]: <a href="http://cython.org/">http://cython.org/</a>
[11]: /images/python/gpujs-performance/vars.tiff
[12]: /images/python/gpujs-performance/station_data.json</p>
</article></div></div></main>
<footer class="site-footer"><div class="wrapper"><div class="footer-col-wrapper"><div class="footer-col  footer-col-1"><ul class="contact-list"><li>GeoExamples - Roger Veciana</li></ul></div>

	<div class="footer-col  footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/rveciana"><span class="icon  icon--github"><svg viewBox="0 0 16 16"><path fill="#89b889" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg></span>

						<span class="username">rveciana</span></a></li>

			<li><a href="https://twitter.com/rveciana"><span class="icon  icon--twitter"><svg viewBox="0 0 16 16"><path fill="#89b889" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                    c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg></span>

						<span class="username">rveciana</span></a></li>
			<li><a href="https://www.linkedin.com/in/rogerveciana"><span class="icon  icon--twitter"><svg width="16" height="15.28958"><path d="M 0,1.77606 Q 0,1.00386 0.54054,0.50193 1.08108,0 1.94595,0 2.79537,0 3.32047,0.49421 3.86101,1.00386 3.86101,1.8224 q 0,0.74131 -0.5251,1.23552 -0.54054,0.50965 -1.42085,0.50965 l -0.0154,0 q -0.84942,0 -1.37452,-0.50965 Q 4e-5,2.54827 4e-5,1.77606 Z m 0.20078,13.51352 0,-10.3166 3.42857,0 0,10.3166 -3.42857,0 z m 5.32818,0 3.42857,0 0,-5.76062 q 0,-0.54054 0.12355,-0.83398 0.21622,-0.52509 0.65638,-0.88803 0.44015,-0.36293 1.10424,-0.36293 1.72973,0 1.72973,2.33205 l 0,5.51351 3.42857,0 0,-5.91506 Q 16,7.08881 14.91892,5.90734 13.83784,4.72587 12.06178,4.72587 q -1.99228,0 -3.10425,1.71429 l 0,0.0309 -0.0154,0 0.0154,-0.0309 0,-1.46718 -3.42857,0 q 0.0309,0.49421 0.0309,3.07336 0,2.57915 -0.0309,7.24324 z"></path></svg></span>

						<span class="username">rogerveciana</span></a></li></ul></div>

	<div class="footer-col  footer-col-3"><p class="text">I am a software developer and meteorologist who likes mapping. I put here the things I learn on my free time.</p>
		<p class="text">Roger Veciana i Rovira</p></div></div></div></footer>



	<script type="svelte-data" url="/summary_pages.json">{"status":200,"statusText":"","headers":{"content-type":"application/json"},"body":"[{\"title\":\"About\",\"permalink\":\"\u002Fabout\",\"excerpt\":\"\u003Cp\u003E{{ site.author.name }}\u003C\u002Fp\u003E\"},{\"title\":\"CV\",\"permalink\":\"\u002Fcv\",\"excerpt\":\"\u003Ch2 id=\\\"jobs\\\"\u003EJobs\u003C\u002Fh2\u003E\",\"avoidMainMenu\":true},{\"title\":\"Projects\",\"permalink\":\"\u002Fprojects\",\"excerpt\":\"\u003Cp\u003ESome of my personal projects:\u003C\u002Fp\u003E\"}]"}</script>

	<script type="svelte-data" url="gpujs-mapping-performance.html.json">{"status":200,"statusText":"","headers":{"content-type":"application/json"},"body":"{\"title\":\"gpu.js performance\",\"contents\":\"\u003Cp\u003EIn the [last post][1] we explained how to make a little more complex calculations with [gpu.js][2]. But, how efficient is?\u003C\u002Fp\u003E\\n\u003Cp\u003EThe temperature calculation is a task I did many years ago, with pure python. Using pure python is a really bad idea in this case, having tools like numpy, cython, etc. The times were about 50 seconds or more, while gpu.js lasts about 1.5 seconds! More than an order of magnitude.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"the-code\\\"\u003EThe code\u003C\u002Fh2\u003E\\n\u003Cp\u003EI made an [example script][3] to test the timing. The result should be the same [as in gpu.js][1], but I made the residuals interpolation calculations in different alternatives, two of them may be different.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo run the script you will need two things:\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"dependencies\\\"\u003EDependencies\u003C\u002Fh3\u003E\\n\u003Cp\u003EMy \u003Cem\u003Epip list\u003C\u002Fem\u003E command returns this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ecycler (0.10.0)\\nCython (0.28.5)\\nGDAL (2.3.1)\\nmatplotlib (2.2.3)\\nnumpy (1.15.1)\\nscikit-learn (0.19.2)\\nscipy (1.1.0)\\nsklearn (0.0)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBasically, scikit-learn, with numpy and scipy plus the cython library. Also, matplotlib to plot the data.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo compile the cython part, there is a \u003Cem\u003Esetup.py\u003C\u002Fem\u003E file that has to be run by:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython setup.py build_ext --inplace\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ENow, by running\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython calculate_temp.py\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EYou will get all the benchmarks\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"multi-linear-regression\\\"\u003EMulti linear regression\u003C\u002Fh3\u003E\\n\u003Cp\u003ETo get the regression coefficients, I used scikit-learn:\\n\\ndef calculate_regression(data_file):\\nregr = LinearRegression()\\n\u003Cpre\u003E\u003Ccode\u003Ewith open(data_file) as f_p:\\n    data = load(f_p)\\n    temps = []\\n    predictors = []\\n    lats = []\\n    lons = []\\n    for station_data in data:\\n        temps.append(station_data[&#39;temp&#39;])\\n        predictors.append([station_data[&#39;alt&#39;], station_data[&#39;dist&#39;]])\\n        lats.append(station_data[&#39;lat&#39;])\\n        lons.append(station_data[&#39;lon&#39;])\\n\\n    regr.fit(predictors, temps)\\n    score = regr.score(predictors, temps)\\n    residuals = regr.predict(predictors) - temps\\n\\n    print(\\\"Multiple linear regression score: {}\\\".format(score))\\n    return {&#39;coefs&#39;: regr.coef_, &#39;intercept&#39;: regr.intercept_,\\n            &#39;residuals&#39;: array(residuals),\\n            &#39;lats&#39;: array(lats), &#39;lons&#39;: array(lons)}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fp\u003E\\n\u003Cp\u003EWhich is quite straightforward. Just prepare the data and [follow the docs][6].\u003C\u002Fp\u003E\\n\u003Cp\u003ENote that the residuals are created applying the regression to the original data:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Eresiduals = regr.predict(predictors) - temps\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EIt&#39;s a clean and fast way to do it and allows to access the results later in the script.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"applying-the-regression\\\"\u003EApplying the regression\u003C\u002Fh3\u003E\\n\u003Cp\u003EApplying the regression results is easy with numpy, since it&#39;s just adding several matrices:\\n\\ndef create*regression_field(regression, vars_file):\\nd_s = gdal.Open(vars_file)\\ndistances = d_s.GetRasterBand(1).ReadAsArray()\\naltitudes = d_s.GetRasterBand(2).ReadAsArray()\\ntemperature = (regression[&#39;intercept&#39;] +\\naltitudes * regression[&#39;coefs&#39;][0] +\\ndistances _ regression[&#39;coefs&#39;][1])\\nreturn temperature\\n\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"interpolating-the-residuals\\\"\u003EInterpolating the residuals\u003C\u002Fh3\u003E\\n\u003Cp\u003EInterpolating the residuals can be done in several ways. I&#39;ve tested three, two after looking example around and the original I used both at my workplace and in the gpu.js example.\u003C\u002Fp\u003E\\n\u003Ch4 id=\\\"rbf\\\"\u003Erbf\u003C\u002Fh4\u003E\\n\u003Cp\u003EThe [radial basis function][8] is the one most srecommended by scipy. The results can be a bit strange and the performance is poor, but:\u003C\u002Fp\u003E\\n\u003Cp\u003E\\ndef rbf(regression, dimensions):\\nxi = linspace(regression[&#39;lons&#39;].min(), regression[&#39;lons&#39;].max(),\\ndimensions[1])\\nyi = linspace(regression[&#39;lats&#39;].min(), regression[&#39;lats&#39;].max(),\\ndimensions[0])\\nxi, yi = meshgrid(xi, yi)\\nxi, yi = xi.flatten(), yi.flatten()\\ninterp = Rbf(regression[&#39;lons&#39;], regression[&#39;lats&#39;],\\nregression[&#39;residuals&#39;], function=&#39;linear&#39;)\\n\u003Cpre\u003E\u003Ccode\u003Eresiduals_field = interp(xi, yi).reshape(dimensions)\\nreturn residuals_field\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fp\u003E\\n\u003Cp\u003EThe code, basically prepares the data for the \u003Cem\u003ERbf\u003C\u002Fem\u003E function.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"idw\\\"\u003Eidw\u003C\u002Fh3\u003E\\n\u003Cp\u003EThe inverse of the distance weighted code is [taken from a GitHub repo][9]. It&#39;s really efficient and the result is good, but more difficult to understand than the regular inverse of the distance. Also, maintains steep changes, which is not the best situation in our case, where we want a smooth residuals field all around, even if a single station has a different local value:\u003C\u002Fp\u003E\\n\u003Cp\u003E\\ndef idw(regression, dimensions):\\nX1 = array(list(zip(regression[&#39;lons&#39;], regression[&#39;lats&#39;])))\\n\u003Cpre\u003E\u003Ccode\u003Eidw_tree = tree(X1, regression[&#39;residuals&#39;])\\n\\nxi = linspace(regression[&#39;lons&#39;].min(), regression[&#39;lons&#39;].max(),\\n              dimensions[1])\\nyi = linspace(regression[&#39;lats&#39;].min(), regression[&#39;lats&#39;].max(),\\n              dimensions[0])\\nX2 = meshgrid(xi, yi)\\nX2 = reshape(X2, (2, -1)).T\\nz2 = idw_tree(X2)\\n\\nreturn z2.reshape(dimensions)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fp\u003E\\n\u003Cp\u003EAgain, the code is basically preparing the data for the function.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"inverse-of-the-distance-using-cython\\\"\u003EInverse of the distance using cython\u003C\u002Fh3\u003E\\n\u003Cp\u003EThis is the original code I used, and the one in the [previous post][1]. Calculating it with pure numpy was a bit difficult, so I made the original algorithm optimized with [cython][10], so it&#39;s as fast as coded in C. The code to call it is:\u003C\u002Fp\u003E\\n\u003Cp\u003E\\ndef cython_id(regression, dimensions):\\n\u003Cpre\u003E\u003Ccode\u003Edata = {}\\n\\nfor i in range(len(regression[&#39;lons&#39;])):\\n    data[i] = {&#39;x&#39;: regression[&#39;lons&#39;][i],\\n               &#39;y&#39;: regression[&#39;lats&#39;][i],\\n               &#39;value&#39;: regression[&#39;residuals&#39;][i]}\\n\\ngeotransform = [min(regression[&#39;lons&#39;]),\\n    (max(regression[&#39;lons&#39;]) - min(regression[&#39;lons&#39;]))\u002Fdimensions[1],\\n    0,\\n    max(regression[&#39;lats&#39;]),\\n    0,\\n    (min(regression[&#39;lats&#39;]) - max(regression[&#39;lats&#39;]))\u002Fdimensions[0]\\n]\\n\\nresult = interpolate_residuals(data, dimensions, geotransform)\\nreturn result\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\\nNote that I used geotransform, which turns things properly.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe cython code is:\\n\\n#cython: boundscheck=False, wraparound=False, nonecheck=False, cdivision=True\\n\\nimport numpy as np\\ncimport numpy as np\\nfrom libc.math cimport sqrt\\nfrom libc.math cimport pow\\nfrom cpython cimport array\\nimport array\\n\\nDTYPE = np.float64\\nctypedef np.float64_t DTYPE_t\\n\\ndef interpolate_residuals(residues, size, geotransform):\\ncdef array.array da = array.array(&#39;d&#39;, [])\\narray.resize(da, size[0] * size[1])\\ncdef double[:] cda = da\\n\u003Cpre\u003E\u003Ccode\u003Expos0 = []\\nypos0 = []\\nvalues0 = []\\n\\nfor key in residues.keys():\\n    xpos0.append(residues[key][&#39;x&#39;])\\n    ypos0.append(residues[key][&#39;y&#39;])\\n    values0.append(residues[key][&#39;value&#39;])\\n\\ncdef int N\\nN = len(xpos0)\\n#http:\u002F\u002Fcython.readthedocs.io\u002Fen\u002Flatest\u002Fsrc\u002Ftutorial\u002Farray.html\\ncdef array.array xpos = array.array(&#39;d&#39;, xpos0)\\ncdef double[:] cxpos = xpos\\ncdef array.array ypos = array.array(&#39;d&#39;, ypos0)\\ncdef double[:] cypos = ypos\\ncdef array.array values = array.array(&#39;d&#39;, values0)\\ncdef double[:] cvalues = values\\n\\ncdef int i, j\\ncdef int xsize = size[1]\\ncdef int ysize = size[0]\\ncdef double y\\ncdef double x\\n\\ncdef array.array geotransform0 = array.array(&#39;d&#39;, geotransform)\\ncdef double[:] cgeotransform = geotransform0\\n\\nfor j in range(ysize):\\n    y = cgeotransform[3] + j * cgeotransform[5]\\n    for i in range(xsize):\\n        x = cgeotransform[0] + i * cgeotransform[1]\\n        cda[i + j * xsize] = point_residue(x, y, cxpos, cypos, cvalues, N)\\n\\ndata_array = np.array(cda)\\nreturn data_array.reshape(size)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\ncdef float point_residue(double x, double y, double[:] xpos, double[:] ypos, double[:] values, int N):\\ncdef int power = 2\\ncdef int smoothing = 0\\ncdef double numerator = 0\\ncdef int i\\ncdef double denominator\\ndenominator = 0\\n\u003Cpre\u003E\u003Ccode\u003Efor i in range(N):\\n    dist = sqrt((x - xpos[i]) ** 2 + (\\n        y - ypos[i]) ** 2 + smoothing * smoothing)\\n\\n    if dist \u003C 0.00000000001:\\n        return values[i]\\n    numerator = numerator + (values[i] \u002F pow(dist, power))\\n    denominator = denominator + (1 \u002F pow(dist, power))\\n\\nif denominator != 0:\\n    return numerator \u002F denominator\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fp\u003E\\n\u003Cp\u003EYou have to run\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython setup.py build_ext --inplace\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eto compile it before running the script for the first time.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"results\\\"\u003EResults\u003C\u002Fh2\u003E\\n\u003Cp\u003EIn my computer, which is not a new or powerful one, the times were, for the common steps:\u003C\u002Fp\u003E\\n\u003Ctable\u003E\\n\u003Cthead\u003E\\n\u003Ctr\u003E\\n\u003Cth\u003EOperation\u003C\u002Fth\u003E\\n\u003Cth\u003EElapsed time\u003C\u002Fth\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Fthead\u003E\\n\u003Ctbody\u003E\u003Ctr\u003E\\n\u003Ctd\u003ERegression time\u003C\u002Ftd\u003E\\n\u003Ctd\u003E3 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003ETemperature field time\u003C\u002Ftd\u003E\\n\u003Ctd\u003E44 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003EFinal field time\u003C\u002Ftd\u003E\\n\u003Ctd\u003E2 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003EDrawing time\u003C\u002Ftd\u003E\\n\u003Ctd\u003E402 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\\n\u003Cp\u003EWith the different methods, the times were:\u003C\u002Fp\u003E\\n\u003Ctable\u003E\\n\u003Cthead\u003E\\n\u003Ctr\u003E\\n\u003Cth\u003EOperation\u003C\u002Fth\u003E\\n\u003Cth\u003EResiduals field time\u003C\u002Fth\u003E\\n\u003Cth\u003ETotal time\u003C\u002Fth\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Fthead\u003E\\n\u003Ctbody\u003E\u003Ctr\u003E\\n\u003Ctd\u003ERbf\u003C\u002Ftd\u003E\\n\u003Ctd\u003E4101 ms\u003C\u002Ftd\u003E\\n\u003Ctd\u003E4551 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003Eidw\u003C\u002Ftd\u003E\\n\u003Ctd\u003E881 ms\u003C\u002Ftd\u003E\\n\u003Ctd\u003E1084 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003Ecython\u003C\u002Ftd\u003E\\n\u003Ctd\u003E2571 ms\u003C\u002Ftd\u003E\\n\u003Ctd\u003E2775 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\\n\u003Cp\u003ESo, in the first place, the residuals interpolation is, by far, the most expensive step. The IDW method I found is the fastest option, although I&#39;m not sure that the result is as good as the cython method with the classical inverse of the distance.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe original gpu.js method lasted:\u003C\u002Fp\u003E\\n\u003Ctable\u003E\\n\u003Cthead\u003E\\n\u003Ctr\u003E\\n\u003Cth\u003EOperation\u003C\u002Fth\u003E\\n\u003Cth\u003EElapsed time\u003C\u002Fth\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Fthead\u003E\\n\u003Ctbody\u003E\u003Ctr\u003E\\n\u003Ctd\u003EMultiple linear regression\u003C\u002Ftd\u003E\\n\u003Ctd\u003E2 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003ECalculate the regression field\u003C\u002Ftd\u003E\\n\u003Ctd\u003E209 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003ECalculate the residuals field\u003C\u002Ftd\u003E\\n\u003Ctd\u003E1084 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003ECalculate the final field\u003C\u002Ftd\u003E\\n\u003Ctd\u003E52 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003EDraw the regression field\u003C\u002Ftd\u003E\\n\u003Ctd\u003E65 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003EDraw residuals field\u003C\u002Ftd\u003E\\n\u003Ctd\u003E70 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003EDraw final result\u003C\u002Ftd\u003E\\n\u003Ctd\u003E67 ms\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Cstrong\u003ETotal time\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Cstrong\u003E1549 ms\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\\n\u003Cp\u003ESo it&#39;s a really good performance if you think that it&#39;s run on the browser using a non compiled language (although using the GPU, of course!)\u003C\u002Fp\u003E\\n\u003Cp\u003EFinally, it would be nice to check the performance against python + GPU, but I have never worked with it.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"links\\\"\u003ELinks\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003E[Last post: Complex GIS calculations with gpu.js: Temperature interpolation][1]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[The gpu.js web site][2]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[scikit-learn multiple linear regression][7]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[The example script][3]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[setup.py for cython][4]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[The cython function][5]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[idw file][6]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[The vars.tiff file][11]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[The station data file][12]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[radial basis function][8]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[IDW library][9]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E[cython][10]\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E[1]: \u002Fother\u002F2018\u002F09\u002F17\u002Fgpujs-example.html\\n[2]: \u003Ca href=\\\"http:\u002F\u002Fgpu.rocks\\\"\u003Ehttp:\u002F\u002Fgpu.rocks\u003C\u002Fa\u003E\\n[3]: \u002Fimages\u002Fpython\u002Fgpujs-performance\u002Fcalculate_temp.py\\n[4]: \u002Fimages\u002Fpython\u002Fgpujs-performance\u002Fsetup.py\\n[5]: \u002Fimages\u002Fpython\u002Fgpujs-performance\u002Finterpolate_residuals.pyx\\n[6]: \u002Fimages\u002Fpython\u002Fgpujs-performance\u002Fidw.py\\n[7]: scikit-learn.org\u002Fstable\u002Fmodules\u002Fgenerated\u002Fsklearn.linear_model.LinearRegression.html\\n[8]: \u003Ca href=\\\"https:\u002F\u002Fdocs.scipy.org\u002Fdoc\u002Fscipy\u002Freference\u002Fgenerated\u002Fscipy.interpolate.Rbf.html\\\"\u003Ehttps:\u002F\u002Fdocs.scipy.org\u002Fdoc\u002Fscipy\u002Freference\u002Fgenerated\u002Fscipy.interpolate.Rbf.html\u003C\u002Fa\u003E\\n[9]: \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fpaulbrodersen\u002Finverse_distance_weighting\\\"\u003Ehttps:\u002F\u002Fgithub.com\u002Fpaulbrodersen\u002Finverse_distance_weighting\u003C\u002Fa\u003E\\n[10]: \u003Ca href=\\\"http:\u002F\u002Fcython.org\u002F\\\"\u003Ehttp:\u002F\u002Fcython.org\u002F\u003C\u002Fa\u003E\\n[11]: \u002Fimages\u002Fpython\u002Fgpujs-performance\u002Fvars.tiff\\n[12]: \u002Fimages\u002Fpython\u002Fgpujs-performance\u002Fstation_data.json\u003C\u002Fp\u003E\\n\",\"tags\":[\"GPU\",\"gpujs\",\"cython\"],\"date\":\"2018-09-18T00:00:00.000Z\"}"}</script>
</div>
	</body>
</html>
