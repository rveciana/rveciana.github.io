{"title":"gpu.js performance","contents":"<p>In the [last post][1] we explained how to make a little more complex calculations with [gpu.js][2]. But, how efficient is?</p>\n<p>The temperature calculation is a task I did many years ago, with pure python. Using pure python is a really bad idea in this case, having tools like numpy, cython, etc. The times were about 50 seconds or more, while gpu.js lasts about 1.5 seconds! More than an order of magnitude.</p>\n<h2 id=\"the-code\">The code</h2>\n<p>I made an [example script][3] to test the timing. The result should be the same [as in gpu.js][1], but I made the residuals interpolation calculations in different alternatives, two of them may be different.</p>\n<p>To run the script you will need two things:</p>\n<h3 id=\"dependencies\">Dependencies</h3>\n<p>My <em>pip list</em> command returns this:</p>\n<pre><code>cycler (0.10.0)\nCython (0.28.5)\nGDAL (2.3.1)\nmatplotlib (2.2.3)\nnumpy (1.15.1)\nscikit-learn (0.19.2)\nscipy (1.1.0)\nsklearn (0.0)</code></pre><p>Basically, scikit-learn, with numpy and scipy plus the cython library. Also, matplotlib to plot the data.</p>\n<p>To compile the cython part, there is a <em>setup.py</em> file that has to be run by:</p>\n<pre><code>python setup.py build_ext --inplace</code></pre><p>Now, by running</p>\n<pre><code>python calculate_temp.py</code></pre><p>You will get all the benchmarks</p>\n<h3 id=\"multi-linear-regression\">Multi linear regression</h3>\n<p>To get the regression coefficients, I used scikit-learn:\n\ndef calculate_regression(data_file):\nregr = LinearRegression()\n<pre><code>with open(data_file) as f_p:\n    data = load(f_p)\n    temps = []\n    predictors = []\n    lats = []\n    lons = []\n    for station_data in data:\n        temps.append(station_data[&#39;temp&#39;])\n        predictors.append([station_data[&#39;alt&#39;], station_data[&#39;dist&#39;]])\n        lats.append(station_data[&#39;lat&#39;])\n        lons.append(station_data[&#39;lon&#39;])\n\n    regr.fit(predictors, temps)\n    score = regr.score(predictors, temps)\n    residuals = regr.predict(predictors) - temps\n\n    print(\"Multiple linear regression score: {}\".format(score))\n    return {&#39;coefs&#39;: regr.coef_, &#39;intercept&#39;: regr.intercept_,\n            &#39;residuals&#39;: array(residuals),\n            &#39;lats&#39;: array(lats), &#39;lons&#39;: array(lons)}</code></pre>\n</p>\n<p>Which is quite straightforward. Just prepare the data and [follow the docs][6].</p>\n<p>Note that the residuals are created applying the regression to the original data:</p>\n<pre><code>residuals = regr.predict(predictors) - temps</code></pre><p>It&#39;s a clean and fast way to do it and allows to access the results later in the script.</p>\n<h3 id=\"applying-the-regression\">Applying the regression</h3>\n<p>Applying the regression results is easy with numpy, since it&#39;s just adding several matrices:\n\ndef create*regression_field(regression, vars_file):\nd_s = gdal.Open(vars_file)\ndistances = d_s.GetRasterBand(1).ReadAsArray()\naltitudes = d_s.GetRasterBand(2).ReadAsArray()\ntemperature = (regression[&#39;intercept&#39;] +\naltitudes * regression[&#39;coefs&#39;][0] +\ndistances _ regression[&#39;coefs&#39;][1])\nreturn temperature\n</p>\n<h3 id=\"interpolating-the-residuals\">Interpolating the residuals</h3>\n<p>Interpolating the residuals can be done in several ways. I&#39;ve tested three, two after looking example around and the original I used both at my workplace and in the gpu.js example.</p>\n<h4 id=\"rbf\">rbf</h4>\n<p>The [radial basis function][8] is the one most srecommended by scipy. The results can be a bit strange and the performance is poor, but:</p>\n<p>\ndef rbf(regression, dimensions):\nxi = linspace(regression[&#39;lons&#39;].min(), regression[&#39;lons&#39;].max(),\ndimensions[1])\nyi = linspace(regression[&#39;lats&#39;].min(), regression[&#39;lats&#39;].max(),\ndimensions[0])\nxi, yi = meshgrid(xi, yi)\nxi, yi = xi.flatten(), yi.flatten()\ninterp = Rbf(regression[&#39;lons&#39;], regression[&#39;lats&#39;],\nregression[&#39;residuals&#39;], function=&#39;linear&#39;)\n<pre><code>residuals_field = interp(xi, yi).reshape(dimensions)\nreturn residuals_field</code></pre>\n</p>\n<p>The code, basically prepares the data for the <em>Rbf</em> function.</p>\n<h3 id=\"idw\">idw</h3>\n<p>The inverse of the distance weighted code is [taken from a GitHub repo][9]. It&#39;s really efficient and the result is good, but more difficult to understand than the regular inverse of the distance. Also, maintains steep changes, which is not the best situation in our case, where we want a smooth residuals field all around, even if a single station has a different local value:</p>\n<p>\ndef idw(regression, dimensions):\nX1 = array(list(zip(regression[&#39;lons&#39;], regression[&#39;lats&#39;])))\n<pre><code>idw_tree = tree(X1, regression[&#39;residuals&#39;])\n\nxi = linspace(regression[&#39;lons&#39;].min(), regression[&#39;lons&#39;].max(),\n              dimensions[1])\nyi = linspace(regression[&#39;lats&#39;].min(), regression[&#39;lats&#39;].max(),\n              dimensions[0])\nX2 = meshgrid(xi, yi)\nX2 = reshape(X2, (2, -1)).T\nz2 = idw_tree(X2)\n\nreturn z2.reshape(dimensions)</code></pre>\n</p>\n<p>Again, the code is basically preparing the data for the function.</p>\n<h3 id=\"inverse-of-the-distance-using-cython\">Inverse of the distance using cython</h3>\n<p>This is the original code I used, and the one in the [previous post][1]. Calculating it with pure numpy was a bit difficult, so I made the original algorithm optimized with [cython][10], so it&#39;s as fast as coded in C. The code to call it is:</p>\n<p>\ndef cython_id(regression, dimensions):\n<pre><code>data = {}\n\nfor i in range(len(regression[&#39;lons&#39;])):\n    data[i] = {&#39;x&#39;: regression[&#39;lons&#39;][i],\n               &#39;y&#39;: regression[&#39;lats&#39;][i],\n               &#39;value&#39;: regression[&#39;residuals&#39;][i]}\n\ngeotransform = [min(regression[&#39;lons&#39;]),\n    (max(regression[&#39;lons&#39;]) - min(regression[&#39;lons&#39;]))/dimensions[1],\n    0,\n    max(regression[&#39;lats&#39;]),\n    0,\n    (min(regression[&#39;lats&#39;]) - max(regression[&#39;lats&#39;]))/dimensions[0]\n]\n\nresult = interpolate_residuals(data, dimensions, geotransform)\nreturn result</code></pre>\n\nNote that I used geotransform, which turns things properly.</p>\n<p>The cython code is:\n\n#cython: boundscheck=False, wraparound=False, nonecheck=False, cdivision=True\n\nimport numpy as np\ncimport numpy as np\nfrom libc.math cimport sqrt\nfrom libc.math cimport pow\nfrom cpython cimport array\nimport array\n\nDTYPE = np.float64\nctypedef np.float64_t DTYPE_t\n\ndef interpolate_residuals(residues, size, geotransform):\ncdef array.array da = array.array(&#39;d&#39;, [])\narray.resize(da, size[0] * size[1])\ncdef double[:] cda = da\n<pre><code>xpos0 = []\nypos0 = []\nvalues0 = []\n\nfor key in residues.keys():\n    xpos0.append(residues[key][&#39;x&#39;])\n    ypos0.append(residues[key][&#39;y&#39;])\n    values0.append(residues[key][&#39;value&#39;])\n\ncdef int N\nN = len(xpos0)\n#http://cython.readthedocs.io/en/latest/src/tutorial/array.html\ncdef array.array xpos = array.array(&#39;d&#39;, xpos0)\ncdef double[:] cxpos = xpos\ncdef array.array ypos = array.array(&#39;d&#39;, ypos0)\ncdef double[:] cypos = ypos\ncdef array.array values = array.array(&#39;d&#39;, values0)\ncdef double[:] cvalues = values\n\ncdef int i, j\ncdef int xsize = size[1]\ncdef int ysize = size[0]\ncdef double y\ncdef double x\n\ncdef array.array geotransform0 = array.array(&#39;d&#39;, geotransform)\ncdef double[:] cgeotransform = geotransform0\n\nfor j in range(ysize):\n    y = cgeotransform[3] + j * cgeotransform[5]\n    for i in range(xsize):\n        x = cgeotransform[0] + i * cgeotransform[1]\n        cda[i + j * xsize] = point_residue(x, y, cxpos, cypos, cvalues, N)\n\ndata_array = np.array(cda)\nreturn data_array.reshape(size)</code></pre>\ncdef float point_residue(double x, double y, double[:] xpos, double[:] ypos, double[:] values, int N):\ncdef int power = 2\ncdef int smoothing = 0\ncdef double numerator = 0\ncdef int i\ncdef double denominator\ndenominator = 0\n<pre><code>for i in range(N):\n    dist = sqrt((x - xpos[i]) ** 2 + (\n        y - ypos[i]) ** 2 + smoothing * smoothing)\n\n    if dist < 0.00000000001:\n        return values[i]\n    numerator = numerator + (values[i] / pow(dist, power))\n    denominator = denominator + (1 / pow(dist, power))\n\nif denominator != 0:\n    return numerator / denominator</code></pre>\n</p>\n<p>You have to run</p>\n<pre><code>python setup.py build_ext --inplace</code></pre><p>to compile it before running the script for the first time.</p>\n<h2 id=\"results\">Results</h2>\n<p>In my computer, which is not a new or powerful one, the times were, for the common steps:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Elapsed time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Regression time</td>\n<td>3 ms</td>\n</tr>\n<tr>\n<td>Temperature field time</td>\n<td>44 ms</td>\n</tr>\n<tr>\n<td>Final field time</td>\n<td>2 ms</td>\n</tr>\n<tr>\n<td>Drawing time</td>\n<td>402 ms</td>\n</tr>\n</tbody></table>\n<p>With the different methods, the times were:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Residuals field time</th>\n<th>Total time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rbf</td>\n<td>4101 ms</td>\n<td>4551 ms</td>\n</tr>\n<tr>\n<td>idw</td>\n<td>881 ms</td>\n<td>1084 ms</td>\n</tr>\n<tr>\n<td>cython</td>\n<td>2571 ms</td>\n<td>2775 ms</td>\n</tr>\n</tbody></table>\n<p>So, in the first place, the residuals interpolation is, by far, the most expensive step. The IDW method I found is the fastest option, although I&#39;m not sure that the result is as good as the cython method with the classical inverse of the distance.</p>\n<p>The original gpu.js method lasted:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Elapsed time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multiple linear regression</td>\n<td>2 ms</td>\n</tr>\n<tr>\n<td>Calculate the regression field</td>\n<td>209 ms</td>\n</tr>\n<tr>\n<td>Calculate the residuals field</td>\n<td>1084 ms</td>\n</tr>\n<tr>\n<td>Calculate the final field</td>\n<td>52 ms</td>\n</tr>\n<tr>\n<td>Draw the regression field</td>\n<td>65 ms</td>\n</tr>\n<tr>\n<td>Draw residuals field</td>\n<td>70 ms</td>\n</tr>\n<tr>\n<td>Draw final result</td>\n<td>67 ms</td>\n</tr>\n<tr>\n<td><strong>Total time</strong></td>\n<td><strong>1549 ms</strong></td>\n</tr>\n</tbody></table>\n<p>So it&#39;s a really good performance if you think that it&#39;s run on the browser using a non compiled language (although using the GPU, of course!)</p>\n<p>Finally, it would be nice to check the performance against python + GPU, but I have never worked with it.</p>\n<h2 id=\"links\">Links</h2>\n<ul>\n<li><p>[Last post: Complex GIS calculations with gpu.js: Temperature interpolation][1]</p>\n</li>\n<li><p>[The gpu.js web site][2]</p>\n</li>\n<li><p>[scikit-learn multiple linear regression][7]</p>\n</li>\n<li><p>[The example script][3]</p>\n</li>\n<li><p>[setup.py for cython][4]</p>\n</li>\n<li><p>[The cython function][5]</p>\n</li>\n<li><p>[idw file][6]</p>\n</li>\n<li><p>[The vars.tiff file][11]</p>\n</li>\n<li><p>[The station data file][12]</p>\n</li>\n<li><p>[radial basis function][8]</p>\n</li>\n<li><p>[IDW library][9]</p>\n</li>\n<li><p>[cython][10]</p>\n</li>\n</ul>\n<p>[1]: /other/2018/09/17/gpujs-example.html\n[2]: <a href=\"http://gpu.rocks\">http://gpu.rocks</a>\n[3]: /images/python/gpujs-performance/calculate_temp.py\n[4]: /images/python/gpujs-performance/setup.py\n[5]: /images/python/gpujs-performance/interpolate_residuals.pyx\n[6]: /images/python/gpujs-performance/idw.py\n[7]: scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html\n[8]: <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html\">https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html</a>\n[9]: <a href=\"https://github.com/paulbrodersen/inverse_distance_weighting\">https://github.com/paulbrodersen/inverse_distance_weighting</a>\n[10]: <a href=\"http://cython.org/\">http://cython.org/</a>\n[11]: /images/python/gpujs-performance/vars.tiff\n[12]: /images/python/gpujs-performance/station_data.json</p>\n","tags":["GPU","gpujs","cython"],"date":"2018-09-18T00:00:00.000Z"}