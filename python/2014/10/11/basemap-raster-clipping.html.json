{"title":"Basemap raster clipping with a shapefile","contents":"<p>Basemap is a great library for mapping faster than other python options, but there are some usual things I couldn&#39;t find how to do. Clipping a raster using a shape is one of them. Here&#39;s how do I do it:</p>\n<p>As usual, all the code can be found at <a href=\"https://github.com/rveciana/geoexamples/tree/master/python/basemap_clipping\">GitHub</a></p>\n<h2 id=\"getting-some-data\">Getting some data</h2>\n<p>The example plots some elevation data, taken from the SRTM. After looking for some options, the easiest to work with was this one: <a href=\"http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp\">http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp</a>\nThe shapefile will be the border of Andorra, taken from Natural Earth\nThe result is a little poor because the resolution is low, but works well for the example.</p>\n<img src=\"/images/python/basemapclipping.png\" width=\"50%\"/>\n\n<h2 id=\"the-script\">The script</h2>\n<p>{% highlight python linenos %}\nfrom mpl_toolkits.basemap import Basemap<br>from matplotlib.path import Path<br>from matplotlib.patches import PathPatch<br>import matplotlib.pyplot as plt<br>from osgeo import gdal<br>import numpy<br>import shapefile</p>\n<p>fig = plt.figure()<br>ax = fig.add_subplot(111)</p>\n<p>sf = shapefile.Reader(&quot;ne_10m_admin_0_countries&quot;)</p>\n<p>for shape_rec in sf.shapeRecords():<br> if shape_rec.record[3] == &#39;Andorra&#39;:<br> vertices = []<br> codes = []<br> pts = shape_rec.shape.points<br> prt = list(shape_rec.shape.parts) + [len(pts)]<br> for i in range(len(prt) - 1):<br> for j in range(prt[i], prt[i+1]):<br> vertices.append((pts[j][0], pts[j][1]))<br> codes += [Path.MOVETO]<br> codes += [Path.LINETO] * (prt[i+1] - prt[i] -2)<br> codes += [Path.CLOSEPOLY]<br> clip = Path(vertices, codes)<br> clip = PathPatch(clip, transform=ax.transData)</p>\n<p>m = Basemap(llcrnrlon=1.4,<br> llcrnrlat=42.4,<br> urcrnrlon=1.77,<br> urcrnrlat=42.7,<br> resolution = None,\nprojection = &#39;cyl&#39;)</p>\n<p>ds = gdal.Open(&#39;srtm_37_04.tif&#39;)<br>data = ds.ReadAsArray()</p>\n<p>gt = ds.GetGeoTransform()<br>x = numpy.linspace(gt[0], gt[0] + gt[1] _ data.shape[1], data.shape[1])<br>y = numpy.linspace(gt[3], gt[3] + gt[5] _ data.shape[0], data.shape[0])</p>\n<p>xx, yy = numpy.meshgrid(x, y)</p>\n<p>cs = m.contourf(xx,yy,data,range(0, 3600, 200))</p>\n<p>for contour in cs.collections:<br> contour.set_clip_path(clip)</p>\n<p>plt.show()\n{% endhighlight %}</p>\n<ul>\n<li>I used the pyshp library for reading the shapefile, since Fiona and GDAL don&#39;t work well together, and OGR was longer</li>\n<li>Lines 14 to 27 create the path. A Matplotlib path is made by two arrays. One with the points (called vertices in the script), and the other with the functions for every point (called codes)<ul>\n<li>In our case, only straight lines have to be used, so there will be a MOVETO to indicate the beginning of the polygon, many LINETO to create the segments and one CLOSEPOLY for closing it</li>\n<li>Of course, only the polygon for Andorra has to be used. I get it from the shapefile attributes</li>\n<li>The prt array is for managing multipolygons, which is not the case, but the code will create correct clipping for multipolygons</li>\n<li>The path is created using the Path function, and then added to a PathPatch, to be able to use it as a closed polygon. Note the trasnform=ax.transData attribute. This assumes the polygon coordinates to be the ones used in the data (longitudes and latitudes in our case). More information here</li>\n</ul>\n</li>\n<li>Next code lines draw the map as usual. I have used a latlon projection, so all the values for the raster and shapefile can be used directly. If the output raster was in an other projection, the shapefile coordinates should be appended to the path using the output projection (m(pts[j][0], pts[j][1]))</li>\n<li>The x and y coordinates are calculated from the GDAL geotransform, and then turned into a matrix using meshgrid</li>\n<li>The clipping itself is made in the lines 48 and 49. For each drawn element, the method set_clip_path is applied</li>\n</ul>\n<h2 id=\"links\">Links</h2>\n<ul>\n<li><a href=\"http://srtm.csi.cgiar.org/SELECTION/inputCoord.asp\">SRTM data download</a></li>\n<li><a href=\"http://matplotlib.org/users/path_tutorial.html\">Matplotlib path tutorial</a></li>\n<li><a href=\"http://matplotlib.org/examples/pylab_examples/image_clip_path.html\">Clipping an image in Basemap</a></li>\n<li><a href=\"http://matplotlib.org/users/transforms_tutorial.html\">Understanding Basemap transformations</a></li>\n<li><a href=\"http://geospatialpython.com/2011/02/clip-raster-using-shapefile.html\">Clipping a raster with GDAL python</a></li>\n</ul>\n","tags":["basemap","GDAL"],"date":"2014-10-11T00:00:00.000Z"}